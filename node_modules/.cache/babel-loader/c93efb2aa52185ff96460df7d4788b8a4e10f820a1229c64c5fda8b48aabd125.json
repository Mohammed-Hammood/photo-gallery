{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from 'react';\nimport { useAppDispatch } from 'store/hooks';\nimport { setErrors } from 'store/slicers/errors';\nfunction useFetch(props) {\n  _s();\n  const [loading, setLoading] = useState(props.loading !== undefined ? props.loading : false);\n  const [callback, setCallback] = useState(() => props.callback || null);\n  const [message, setMessage] = useState(null);\n  const [method, setMethod] = useState(props.method || \"GET\");\n  const [data, setData] = useState(null);\n  const [url, setUrl] = useState(props.url);\n  const [showMessage, setShowMessage] = useState(props.showMessage !== undefined ? props.showMessage : true);\n  const dispatch = useAppDispatch();\n  const condition = res => {\n    if (props.condition && typeof props.condition !== 'boolean') return props.condition(res);else if (props.condition && typeof props.condition === 'boolean') return props.condition;\n    return false;\n  };\n  useEffect(() => {\n    const headers = props.headers || {\n      'Content-Type': 'application/json'\n    };\n    const options = {\n      headers: headers,\n      method: method\n    };\n    if (data && ['POST', 'PUT', 'DELETE'].includes(method)) options.body = JSON.stringify(data);\n    const sendRequest = async url => {\n      try {\n        const req = await fetch(url, options);\n        if (req.status !== 200) {\n          throw {\n            status: req.status,\n            statusText: req.statusText,\n            type: req.type,\n            ok: req.ok\n          };\n        }\n        const res = await req.json();\n        if (res && res.status === 200 || condition(res)) {\n          if (callback) callback({\n            data: res,\n            method,\n            url\n          });\n        } else {\n          setMessage({\n            status: res.status,\n            message: res.message\n          });\n        }\n      } catch (err) {\n        const errors = {\n          status: err.status,\n          statusText: err.statusText,\n          type: err.type,\n          ok: err.ok\n        };\n        dispatch(setErrors({\n          errors: errors,\n          showMessage: showMessage\n        }));\n        setMessage({\n          status: err.status,\n          message: err.message\n        });\n      } finally {\n        setLoading(false);\n        setUrl(null);\n      }\n    };\n    if (url && !loading) {\n      setLoading(true);\n      setMessage(null);\n      sendRequest(url);\n    }\n  }, [dispatch, url, loading, data, message, showMessage, method, condition, props.headers, setUrl, setMethod, setLoading, props]);\n  return {\n    loading,\n    message,\n    method,\n    url,\n    setUrl,\n    setMessage,\n    setData,\n    setMethod,\n    setLoading,\n    setShowMessage,\n    setCallback\n  };\n}\n_s(useFetch, \"bdJyil2+I6R7Oc6Zm+qb89ODM3Q=\", false, function () {\n  return [useAppDispatch];\n});\nexport default useFetch;","map":{"version":3,"names":["useState","useEffect","useAppDispatch","setErrors","useFetch","props","_s","loading","setLoading","undefined","callback","setCallback","message","setMessage","method","setMethod","data","setData","url","setUrl","showMessage","setShowMessage","dispatch","condition","res","headers","options","includes","body","JSON","stringify","sendRequest","req","fetch","status","statusText","type","ok","json","err","errors"],"sources":["/home/mohammed/worldoftechnology/project-images/client/src/components/hooks/useFetch.tsx"],"sourcesContent":["import { useState, useEffect } from 'react'\nimport { useAppSelector, useAppDispatch } from 'store/hooks';\nimport { setErrors } from 'store/slicers/errors';\nimport { MethodTypes} from \"libs/types\";\n\ninterface InitialRequest {\n    method: MethodTypes;\n    headers: {\n        [key: string]: string\n    },\n    body?: any\n}\n \ntype Props = {\n    callback?: ({ data, method, url }: any ) => void;\n    url?: string | null;\n    showMessage?: boolean;\n    condition?: ((res: any) => boolean) | boolean; \n    headers?: any;\n    loading?: boolean;\n    method?:MethodTypes;\n};\nfunction useFetch(props: Props) {\n    const [loading, setLoading] = useState<boolean>(props.loading !== undefined ? props.loading : false);\n    const [callback, setCallback] = useState<((value:any)=> void) | null >(()=> props.callback || null );\n    const [message, setMessage] = useState<null | { status: number, message: string }>(null)\n    const [method, setMethod] = useState<MethodTypes>(props.method || \"GET\");\n    const [data, setData] = useState<any>(null);\n    const [url, setUrl] = useState<string | null | undefined>(props.url);\n    const [showMessage, setShowMessage] = useState<boolean>(props.showMessage !== undefined ? props.showMessage : true);\n    const dispatch = useAppDispatch();\n    const condition = (res: any): boolean => {\n        if (props.condition && typeof props.condition !== 'boolean') return props.condition(res);\n        else if (props.condition && typeof props.condition === 'boolean') return props.condition;\n        return false;\n    }\n    useEffect(() => {\n        const headers = props.headers || { 'Content-Type': 'application/json',};\n        const options: InitialRequest = {\n            headers: headers,\n            method: method\n        }\n        if (data && ['POST', 'PUT', 'DELETE'].includes(method)) options.body = JSON.stringify(data);\n\n        const sendRequest = async (url: string): Promise<void> => {\n            try {\n                const req = await fetch(url, options);\n                if (req.status !== 200) {\n                    throw { status: req.status, statusText: req.statusText, type: req.type, ok: req.ok }\n                }\n                const res = await req.json();\n                if ((res && res.status === 200) || condition(res)) {\n                    if(callback)callback({ data: res, method, url });\n                }\n                else {\n                    setMessage({ status: res.status, message: res.message })\n                }\n            } catch (err: any) {\n                const errors = {status:err.status, statusText:err.statusText, type:err.type, ok: err.ok};\n                dispatch(setErrors({ errors: errors, showMessage: showMessage }))\n                setMessage({ status: err.status, message: err.message });\n            } finally {\n                setLoading(false);\n                setUrl(null);\n            }\n        }\n        if (url && !loading) {\n            setLoading(true);\n            setMessage(null);\n            sendRequest(url);\n        }\n    }, [dispatch,  url, loading, data, message, showMessage, method, condition, props.headers, setUrl, setMethod, setLoading, props])\n    return {\n        loading,\n        message,\n        method,\n        url,\n        setUrl,\n        setMessage,\n        setData,\n        setMethod,\n        setLoading,\n        setShowMessage,\n        setCallback,\n    }\n}\nexport default useFetch;"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAC3C,SAAyBC,cAAc,QAAQ,aAAa;AAC5D,SAASC,SAAS,QAAQ,sBAAsB;AAoBhD,SAASC,QAAQA,CAACC,KAAY,EAAE;EAAAC,EAAA;EAC5B,MAAM,CAACC,OAAO,EAAEC,UAAU,CAAC,GAAGR,QAAQ,CAAUK,KAAK,CAACE,OAAO,KAAKE,SAAS,GAAGJ,KAAK,CAACE,OAAO,GAAG,KAAK,CAAC;EACpG,MAAM,CAACG,QAAQ,EAAEC,WAAW,CAAC,GAAGX,QAAQ,CAA+B,MAAKK,KAAK,CAACK,QAAQ,IAAI,IAAI,CAAE;EACpG,MAAM,CAACE,OAAO,EAAEC,UAAU,CAAC,GAAGb,QAAQ,CAA6C,IAAI,CAAC;EACxF,MAAM,CAACc,MAAM,EAAEC,SAAS,CAAC,GAAGf,QAAQ,CAAcK,KAAK,CAACS,MAAM,IAAI,KAAK,CAAC;EACxE,MAAM,CAACE,IAAI,EAAEC,OAAO,CAAC,GAAGjB,QAAQ,CAAM,IAAI,CAAC;EAC3C,MAAM,CAACkB,GAAG,EAAEC,MAAM,CAAC,GAAGnB,QAAQ,CAA4BK,KAAK,CAACa,GAAG,CAAC;EACpE,MAAM,CAACE,WAAW,EAAEC,cAAc,CAAC,GAAGrB,QAAQ,CAAUK,KAAK,CAACe,WAAW,KAAKX,SAAS,GAAGJ,KAAK,CAACe,WAAW,GAAG,IAAI,CAAC;EACnH,MAAME,QAAQ,GAAGpB,cAAc,EAAE;EACjC,MAAMqB,SAAS,GAAIC,GAAQ,IAAc;IACrC,IAAInB,KAAK,CAACkB,SAAS,IAAI,OAAOlB,KAAK,CAACkB,SAAS,KAAK,SAAS,EAAE,OAAOlB,KAAK,CAACkB,SAAS,CAACC,GAAG,CAAC,CAAC,KACpF,IAAInB,KAAK,CAACkB,SAAS,IAAI,OAAOlB,KAAK,CAACkB,SAAS,KAAK,SAAS,EAAE,OAAOlB,KAAK,CAACkB,SAAS;IACxF,OAAO,KAAK;EAChB,CAAC;EACDtB,SAAS,CAAC,MAAM;IACZ,MAAMwB,OAAO,GAAGpB,KAAK,CAACoB,OAAO,IAAI;MAAE,cAAc,EAAE;IAAmB,CAAC;IACvE,MAAMC,OAAuB,GAAG;MAC5BD,OAAO,EAAEA,OAAO;MAChBX,MAAM,EAAEA;IACZ,CAAC;IACD,IAAIE,IAAI,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,QAAQ,CAAC,CAACW,QAAQ,CAACb,MAAM,CAAC,EAAEY,OAAO,CAACE,IAAI,GAAGC,IAAI,CAACC,SAAS,CAACd,IAAI,CAAC;IAE3F,MAAMe,WAAW,GAAG,MAAOb,GAAW,IAAoB;MACtD,IAAI;QACA,MAAMc,GAAG,GAAG,MAAMC,KAAK,CAACf,GAAG,EAAEQ,OAAO,CAAC;QACrC,IAAIM,GAAG,CAACE,MAAM,KAAK,GAAG,EAAE;UACpB,MAAM;YAAEA,MAAM,EAAEF,GAAG,CAACE,MAAM;YAAEC,UAAU,EAAEH,GAAG,CAACG,UAAU;YAAEC,IAAI,EAAEJ,GAAG,CAACI,IAAI;YAAEC,EAAE,EAAEL,GAAG,CAACK;UAAG,CAAC;QACxF;QACA,MAAMb,GAAG,GAAG,MAAMQ,GAAG,CAACM,IAAI,EAAE;QAC5B,IAAKd,GAAG,IAAIA,GAAG,CAACU,MAAM,KAAK,GAAG,IAAKX,SAAS,CAACC,GAAG,CAAC,EAAE;UAC/C,IAAGd,QAAQ,EAACA,QAAQ,CAAC;YAAEM,IAAI,EAAEQ,GAAG;YAAEV,MAAM;YAAEI;UAAI,CAAC,CAAC;QACpD,CAAC,MACI;UACDL,UAAU,CAAC;YAAEqB,MAAM,EAAEV,GAAG,CAACU,MAAM;YAAEtB,OAAO,EAAEY,GAAG,CAACZ;UAAQ,CAAC,CAAC;QAC5D;MACJ,CAAC,CAAC,OAAO2B,GAAQ,EAAE;QACf,MAAMC,MAAM,GAAG;UAACN,MAAM,EAACK,GAAG,CAACL,MAAM;UAAEC,UAAU,EAACI,GAAG,CAACJ,UAAU;UAAEC,IAAI,EAACG,GAAG,CAACH,IAAI;UAAEC,EAAE,EAAEE,GAAG,CAACF;QAAE,CAAC;QACxFf,QAAQ,CAACnB,SAAS,CAAC;UAAEqC,MAAM,EAAEA,MAAM;UAAEpB,WAAW,EAAEA;QAAY,CAAC,CAAC,CAAC;QACjEP,UAAU,CAAC;UAAEqB,MAAM,EAAEK,GAAG,CAACL,MAAM;UAAEtB,OAAO,EAAE2B,GAAG,CAAC3B;QAAQ,CAAC,CAAC;MAC5D,CAAC,SAAS;QACNJ,UAAU,CAAC,KAAK,CAAC;QACjBW,MAAM,CAAC,IAAI,CAAC;MAChB;IACJ,CAAC;IACD,IAAID,GAAG,IAAI,CAACX,OAAO,EAAE;MACjBC,UAAU,CAAC,IAAI,CAAC;MAChBK,UAAU,CAAC,IAAI,CAAC;MAChBkB,WAAW,CAACb,GAAG,CAAC;IACpB;EACJ,CAAC,EAAE,CAACI,QAAQ,EAAGJ,GAAG,EAAEX,OAAO,EAAES,IAAI,EAAEJ,OAAO,EAAEQ,WAAW,EAAEN,MAAM,EAAES,SAAS,EAAElB,KAAK,CAACoB,OAAO,EAAEN,MAAM,EAAEJ,SAAS,EAAEP,UAAU,EAAEH,KAAK,CAAC,CAAC;EACjI,OAAO;IACHE,OAAO;IACPK,OAAO;IACPE,MAAM;IACNI,GAAG;IACHC,MAAM;IACNN,UAAU;IACVI,OAAO;IACPF,SAAS;IACTP,UAAU;IACVa,cAAc;IACdV;EACJ,CAAC;AACL;AAACL,EAAA,CA/DQF,QAAQ;EAAA,QAQIF,cAAc;AAAA;AAwDnC,eAAeE,QAAQ"},"metadata":{},"sourceType":"module","externalDependencies":[]}